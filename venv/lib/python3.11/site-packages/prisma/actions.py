# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class SpellActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Spell]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Spell.prisma().query_raw(
            'SELECT * FROM Spell WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Spell
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Spell.prisma().query_first(
            'SELECT * FROM Spell WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SpellCreateInput,
        include: Optional[types.SpellInclude] = None
    ) -> _PrismaModelT:
        """Create a new Spell record.

        Parameters
        ----------
        data
            Spell record data
        include
            Specifies which relations should be loaded on the returned Spell model

        Returns
        -------
        prisma.models.Spell
            The created Spell record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Spell record from just the required fields
        spell = await Spell.prisma().create(
            data={
                # data to create a Spell record
                'name': 'ggciceaie',
                'source': 'bbehjachib',
                'school': 'cadfabfehe',
                'level': 'dgiiaaijj',
                'castingTime': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SpellCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Spell records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Spell record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Spell.prisma().create_many(
            data=[
                {
                    # data to create a Spell record
                    'name': 'eigcfgbif',
                    'source': 'bagcfbhiig',
                    'school': 'cghideieh',
                    'level': 'biabhbdai',
                    'castingTime': 'idghgaicb',
                },
                {
                    # data to create a Spell record
                    'name': 'fjfddhigg',
                    'source': 'hjaecfifb',
                    'school': 'cbbbjbfcii',
                    'level': 'bbejhfidcb',
                    'castingTime': 'bgeecijdgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SpellWhereUniqueInput,
        include: Optional[types.SpellInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Spell record.

        Parameters
        ----------
        where
            Spell filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Spell model

        Returns
        -------
        prisma.models.Spell
            The deleted Spell record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        spell = await Spell.prisma().delete(
            where={
                'id': 1388290519,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SpellWhereUniqueInput,
        include: Optional[types.SpellInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Spell record.

        Parameters
        ----------
        where
            Spell filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Spell model

        Returns
        -------
        prisma.models.Spell
            The found Spell record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        spell = await Spell.prisma().find_unique(
            where={
                'id': 1647418052,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SpellWhereUniqueInput,
        include: Optional[types.SpellInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Spell record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Spell filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Spell model

        Returns
        -------
        prisma.models.Spell
            The found Spell record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        spell = await Spell.prisma().find_unique_or_raise(
            where={
                'id': 1675546029,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SpellWhereInput] = None,
        cursor: Optional[types.SpellWhereUniqueInput] = None,
        include: Optional[types.SpellInclude] = None,
        order: Optional[Union[types.SpellOrderByInput, List[types.SpellOrderByInput]]] = None,
        distinct: Optional[List[types.SpellScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Spell records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Spell records returned
        skip
            Ignore the first N results
        where
            Spell filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Spell model
        order
            Order the returned Spell records by any field
        distinct
            Filter Spell records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Spell]
            The list of all Spell records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Spell records
        spells = await Spell.prisma().find_many(take=10)

        # find the first 5 Spell records ordered by the source field
        spells = await Spell.prisma().find_many(
            take=5,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SpellWhereInput] = None,
        cursor: Optional[types.SpellWhereUniqueInput] = None,
        include: Optional[types.SpellInclude] = None,
        order: Optional[Union[types.SpellOrderByInput, List[types.SpellOrderByInput]]] = None,
        distinct: Optional[List[types.SpellScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Spell record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Spell filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Spell model
        order
            Order the returned Spell records by any field
        distinct
            Filter Spell records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Spell
            The first Spell record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Spell record ordered by the school field
        spell = await Spell.prisma().find_first(
            skip=1,
            order={
                'school': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SpellWhereInput] = None,
        cursor: Optional[types.SpellWhereUniqueInput] = None,
        include: Optional[types.SpellInclude] = None,
        order: Optional[Union[types.SpellOrderByInput, List[types.SpellOrderByInput]]] = None,
        distinct: Optional[List[types.SpellScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Spell record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Spell filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Spell model
        order
            Order the returned Spell records by any field
        distinct
            Filter Spell records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Spell
            The first Spell record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Spell record ordered by the level field
        spell = await Spell.prisma().find_first_or_raise(
            skip=1,
            order={
                'level': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SpellUpdateInput,
        where: types.SpellWhereUniqueInput,
        include: Optional[types.SpellInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Spell record.

        Parameters
        ----------
        data
            Spell record data specifying what to update
        where
            Spell filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Spell model

        Returns
        -------
        prisma.models.Spell
            The updated Spell record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        spell = await Spell.prisma().update(
            where={
                'id': 1767274722,
            },
            data={
                # data to update the Spell record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SpellWhereUniqueInput,
        data: types.SpellUpsertInput,
        include: Optional[types.SpellInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Spell filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Spell model

        Returns
        -------
        prisma.models.Spell
            The created or updated Spell record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        spell = await Spell.prisma().upsert(
            where={
                'id': 326272115,
            },
            data={
                'create': {
                    'id': 326272115,
                    'name': 'fjfddhigg',
                    'source': 'hjaecfifb',
                    'school': 'cbbbjbfcii',
                    'level': 'bbejhfidcb',
                    'castingTime': 'bgeecijdgg',
                },
                'update': {
                    'name': 'fjfddhigg',
                    'source': 'hjaecfifb',
                    'school': 'cbbbjbfcii',
                    'level': 'bbejhfidcb',
                    'castingTime': 'bgeecijdgg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SpellUpdateManyMutationInput,
        where: types.SpellWhereInput,
    ) -> int:
        """Update multiple Spell records

        Parameters
        ----------
        data
            Spell data to update the selected Spell records to
        where
            Filter to select the Spell records to update

        Returns
        -------
        int
            The total number of Spell records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Spell records
        total = await Spell.prisma().update_many(
            data={
                'castingTime': 'bdedcabahc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SpellWhereInput] = None,
        cursor: Optional[types.SpellWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Spell records present in the database

        Parameters
        ----------
        select
            Select the Spell fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Spell filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SpellCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Spell.prisma().count()

        # results: prisma.types.SpellCountAggregateOutput
        results = await Spell.prisma().count(
            select={
                '_all': True,
                'range': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SpellCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SpellWhereInput] = None,
        cursor: Optional[types.SpellWhereUniqueInput] = None,
    ) -> types.SpellCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SpellCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SpellWhereInput] = None,
        cursor: Optional[types.SpellWhereUniqueInput] = None,
    ) -> Union[int, types.SpellCountAggregateOutput]:
        """Count the number of Spell records present in the database

        Parameters
        ----------
        select
            Select the Spell fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Spell filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SpellCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Spell.prisma().count()

        # results: prisma.types.SpellCountAggregateOutput
        results = await Spell.prisma().count(
            select={
                '_all': True,
                'components': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SpellCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SpellWhereInput] = None
    ) -> int:
        """Delete multiple Spell records.

        Parameters
        ----------
        where
            Optional Spell filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Spell records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Spell records
        total = await Spell.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SpellScalarFieldKeysT'],
        *,
        where: Optional['types.SpellWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SpellAvgAggregateInput'] = None,
        sum: Optional['types.SpellSumAggregateInput'] = None,
        min: Optional['types.SpellMinAggregateInput'] = None,
        max: Optional['types.SpellMaxAggregateInput'] = None,
        having: Optional['types.SpellScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SpellCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SpellScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SpellScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SpellGroupByOutput']:
        """Group Spell records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Spell fields to group records by
        where
            Spell filter to select records
        take
            Limit the maximum number of Spell records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SpellGroupByOutput]
            A list of dictionaries representing the Spell record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Spell records by duration values
        # and count how many records are in each group
        results = await Spell.prisma().group_by(
            ['duration'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LineageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Lineage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Lineage.prisma().query_raw(
            'SELECT * FROM Lineage WHERE id = $1',
            675780521,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Lineage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Lineage.prisma().query_first(
            'SELECT * FROM Lineage WHERE name = $1',
            'heejgedji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LineageCreateInput,
        include: Optional[types.LineageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Lineage record.

        Parameters
        ----------
        data
            Lineage record data
        include
            Specifies which relations should be loaded on the returned Lineage model

        Returns
        -------
        prisma.models.Lineage
            The created Lineage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Lineage record from just the required fields
        lineage = await Lineage.prisma().create(
            data={
                # data to create a Lineage record
                'name': 'bjgjgibgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LineageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Lineage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Lineage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Lineage.prisma().create_many(
            data=[
                {
                    # data to create a Lineage record
                    'name': 'bbbgbhfjge',
                },
                {
                    # data to create a Lineage record
                    'name': 'igbehcbab',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LineageWhereUniqueInput,
        include: Optional[types.LineageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Lineage record.

        Parameters
        ----------
        where
            Lineage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Lineage model

        Returns
        -------
        prisma.models.Lineage
            The deleted Lineage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineage = await Lineage.prisma().delete(
            where={
                'id': 1303003706,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LineageWhereUniqueInput,
        include: Optional[types.LineageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Lineage record.

        Parameters
        ----------
        where
            Lineage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lineage model

        Returns
        -------
        prisma.models.Lineage
            The found Lineage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineage = await Lineage.prisma().find_unique(
            where={
                'id': 1686638315,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LineageWhereUniqueInput,
        include: Optional[types.LineageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Lineage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Lineage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lineage model

        Returns
        -------
        prisma.models.Lineage
            The found Lineage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineage = await Lineage.prisma().find_unique_or_raise(
            where={
                'id': 2000430152,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineageWhereInput] = None,
        cursor: Optional[types.LineageWhereUniqueInput] = None,
        include: Optional[types.LineageInclude] = None,
        order: Optional[Union[types.LineageOrderByInput, List[types.LineageOrderByInput]]] = None,
        distinct: Optional[List[types.LineageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Lineage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Lineage records returned
        skip
            Ignore the first N results
        where
            Lineage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lineage model
        order
            Order the returned Lineage records by any field
        distinct
            Filter Lineage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Lineage]
            The list of all Lineage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Lineage records
        lineages = await Lineage.prisma().find_many(take=10)

        # find the first 5 Lineage records ordered by the id field
        lineages = await Lineage.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LineageWhereInput] = None,
        cursor: Optional[types.LineageWhereUniqueInput] = None,
        include: Optional[types.LineageInclude] = None,
        order: Optional[Union[types.LineageOrderByInput, List[types.LineageOrderByInput]]] = None,
        distinct: Optional[List[types.LineageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Lineage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lineage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lineage model
        order
            Order the returned Lineage records by any field
        distinct
            Filter Lineage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lineage
            The first Lineage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lineage record ordered by the name field
        lineage = await Lineage.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LineageWhereInput] = None,
        cursor: Optional[types.LineageWhereUniqueInput] = None,
        include: Optional[types.LineageInclude] = None,
        order: Optional[Union[types.LineageOrderByInput, List[types.LineageOrderByInput]]] = None,
        distinct: Optional[List[types.LineageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Lineage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lineage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lineage model
        order
            Order the returned Lineage records by any field
        distinct
            Filter Lineage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lineage
            The first Lineage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lineage record ordered by the id field
        lineage = await Lineage.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LineageUpdateInput,
        where: types.LineageWhereUniqueInput,
        include: Optional[types.LineageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Lineage record.

        Parameters
        ----------
        data
            Lineage record data specifying what to update
        where
            Lineage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Lineage model

        Returns
        -------
        prisma.models.Lineage
            The updated Lineage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lineage = await Lineage.prisma().update(
            where={
                'id': 1868141281,
            },
            data={
                # data to update the Lineage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LineageWhereUniqueInput,
        data: types.LineageUpsertInput,
        include: Optional[types.LineageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Lineage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Lineage model

        Returns
        -------
        prisma.models.Lineage
            The created or updated Lineage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineage = await Lineage.prisma().upsert(
            where={
                'id': 1860847622,
            },
            data={
                'create': {
                    'id': 1860847622,
                    'name': 'igbehcbab',
                },
                'update': {
                    'name': 'igbehcbab',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LineageUpdateManyMutationInput,
        where: types.LineageWhereInput,
    ) -> int:
        """Update multiple Lineage records

        Parameters
        ----------
        data
            Lineage data to update the selected Lineage records to
        where
            Filter to select the Lineage records to update

        Returns
        -------
        int
            The total number of Lineage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Lineage records
        total = await Lineage.prisma().update_many(
            data={
                'name': 'beeifcbebf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineageWhereInput] = None,
        cursor: Optional[types.LineageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Lineage records present in the database

        Parameters
        ----------
        select
            Select the Lineage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lineage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LineageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lineage.prisma().count()

        # results: prisma.types.LineageCountAggregateOutput
        results = await Lineage.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LineageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineageWhereInput] = None,
        cursor: Optional[types.LineageWhereUniqueInput] = None,
    ) -> types.LineageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LineageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineageWhereInput] = None,
        cursor: Optional[types.LineageWhereUniqueInput] = None,
    ) -> Union[int, types.LineageCountAggregateOutput]:
        """Count the number of Lineage records present in the database

        Parameters
        ----------
        select
            Select the Lineage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lineage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LineageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lineage.prisma().count()

        # results: prisma.types.LineageCountAggregateOutput
        results = await Lineage.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LineageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LineageWhereInput] = None
    ) -> int:
        """Delete multiple Lineage records.

        Parameters
        ----------
        where
            Optional Lineage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Lineage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Lineage records
        total = await Lineage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LineageScalarFieldKeysT'],
        *,
        where: Optional['types.LineageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LineageAvgAggregateInput'] = None,
        sum: Optional['types.LineageSumAggregateInput'] = None,
        min: Optional['types.LineageMinAggregateInput'] = None,
        max: Optional['types.LineageMaxAggregateInput'] = None,
        having: Optional['types.LineageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LineageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LineageScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.LineageScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.LineageGroupByOutput']:
        """Group Lineage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Lineage fields to group records by
        where
            Lineage filter to select records
        take
            Limit the maximum number of Lineage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LineageGroupByOutput]
            A list of dictionaries representing the Lineage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Lineage records by id values
        # and count how many records are in each group
        results = await Lineage.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RaceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Race]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Race.prisma().query_raw(
            'SELECT * FROM Race WHERE id = $1',
            1628650740,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Race
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Race.prisma().query_first(
            'SELECT * FROM Race WHERE name = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RaceCreateInput,
        include: Optional[types.RaceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Race record.

        Parameters
        ----------
        data
            Race record data
        include
            Specifies which relations should be loaded on the returned Race model

        Returns
        -------
        prisma.models.Race
            The created Race record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Race record from just the required fields
        race = await Race.prisma().create(
            data={
                # data to create a Race record
                'name': 'idfjadbcc',
                'source': 'hgdhbjhhj',
                'lineageId': 429995104,
                'raceId': 1775811865,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RaceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Race records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Race record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Race.prisma().create_many(
            data=[
                {
                    # data to create a Race record
                    'name': 'ijdbeffgg',
                    'source': 'jjfeafhfj',
                    'lineageId': 2102736524,
                    'raceId': 271520213,
                },
                {
                    # data to create a Race record
                    'name': 'efggddide',
                    'source': 'caficfigfb',
                    'lineageId': 1583689592,
                    'raceId': 878442065,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RaceWhereUniqueInput,
        include: Optional[types.RaceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Race record.

        Parameters
        ----------
        where
            Race filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Race model

        Returns
        -------
        prisma.models.Race
            The deleted Race record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        race = await Race.prisma().delete(
            where={
                'id': 1675280054,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RaceWhereUniqueInput,
        include: Optional[types.RaceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Race record.

        Parameters
        ----------
        where
            Race filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Race model

        Returns
        -------
        prisma.models.Race
            The found Race record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        race = await Race.prisma().find_unique(
            where={
                'id': 1627576247,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RaceWhereUniqueInput,
        include: Optional[types.RaceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Race record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Race filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Race model

        Returns
        -------
        prisma.models.Race
            The found Race record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        race = await Race.prisma().find_unique_or_raise(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RaceWhereInput] = None,
        cursor: Optional[types.RaceWhereUniqueInput] = None,
        include: Optional[types.RaceInclude] = None,
        order: Optional[Union[types.RaceOrderByInput, List[types.RaceOrderByInput]]] = None,
        distinct: Optional[List[types.RaceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Race records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Race records returned
        skip
            Ignore the first N results
        where
            Race filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Race model
        order
            Order the returned Race records by any field
        distinct
            Filter Race records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Race]
            The list of all Race records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Race records
        races = await Race.prisma().find_many(take=10)

        # find the first 5 Race records ordered by the source field
        races = await Race.prisma().find_many(
            take=5,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RaceWhereInput] = None,
        cursor: Optional[types.RaceWhereUniqueInput] = None,
        include: Optional[types.RaceInclude] = None,
        order: Optional[Union[types.RaceOrderByInput, List[types.RaceOrderByInput]]] = None,
        distinct: Optional[List[types.RaceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Race record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Race filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Race model
        order
            Order the returned Race records by any field
        distinct
            Filter Race records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Race
            The first Race record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Race record ordered by the lineageId field
        race = await Race.prisma().find_first(
            skip=1,
            order={
                'lineageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RaceWhereInput] = None,
        cursor: Optional[types.RaceWhereUniqueInput] = None,
        include: Optional[types.RaceInclude] = None,
        order: Optional[Union[types.RaceOrderByInput, List[types.RaceOrderByInput]]] = None,
        distinct: Optional[List[types.RaceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Race record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Race filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Race model
        order
            Order the returned Race records by any field
        distinct
            Filter Race records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Race
            The first Race record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Race record ordered by the raceId field
        race = await Race.prisma().find_first_or_raise(
            skip=1,
            order={
                'raceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RaceUpdateInput,
        where: types.RaceWhereUniqueInput,
        include: Optional[types.RaceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Race record.

        Parameters
        ----------
        data
            Race record data specifying what to update
        where
            Race filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Race model

        Returns
        -------
        prisma.models.Race
            The updated Race record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        race = await Race.prisma().update(
            where={
                'id': 60335757,
            },
            data={
                # data to update the Race record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RaceWhereUniqueInput,
        data: types.RaceUpsertInput,
        include: Optional[types.RaceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Race filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Race model

        Returns
        -------
        prisma.models.Race
            The created or updated Race record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        race = await Race.prisma().upsert(
            where={
                'id': 684462146,
            },
            data={
                'create': {
                    'id': 684462146,
                    'name': 'efggddide',
                    'source': 'caficfigfb',
                    'lineageId': 1583689592,
                    'raceId': 878442065,
                },
                'update': {
                    'name': 'efggddide',
                    'source': 'caficfigfb',
                    'lineageId': 1583689592,
                    'raceId': 878442065,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RaceUpdateManyMutationInput,
        where: types.RaceWhereInput,
    ) -> int:
        """Update multiple Race records

        Parameters
        ----------
        data
            Race data to update the selected Race records to
        where
            Filter to select the Race records to update

        Returns
        -------
        int
            The total number of Race records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Race records
        total = await Race.prisma().update_many(
            data={
                'id': 1625503827
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RaceWhereInput] = None,
        cursor: Optional[types.RaceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Race records present in the database

        Parameters
        ----------
        select
            Select the Race fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Race filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RaceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Race.prisma().count()

        # results: prisma.types.RaceCountAggregateOutput
        results = await Race.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RaceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RaceWhereInput] = None,
        cursor: Optional[types.RaceWhereUniqueInput] = None,
    ) -> types.RaceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RaceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RaceWhereInput] = None,
        cursor: Optional[types.RaceWhereUniqueInput] = None,
    ) -> Union[int, types.RaceCountAggregateOutput]:
        """Count the number of Race records present in the database

        Parameters
        ----------
        select
            Select the Race fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Race filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RaceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Race.prisma().count()

        # results: prisma.types.RaceCountAggregateOutput
        results = await Race.prisma().count(
            select={
                '_all': True,
                'source': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RaceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RaceWhereInput] = None
    ) -> int:
        """Delete multiple Race records.

        Parameters
        ----------
        where
            Optional Race filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Race records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Race records
        total = await Race.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RaceScalarFieldKeysT'],
        *,
        where: Optional['types.RaceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RaceAvgAggregateInput'] = None,
        sum: Optional['types.RaceSumAggregateInput'] = None,
        min: Optional['types.RaceMinAggregateInput'] = None,
        max: Optional['types.RaceMaxAggregateInput'] = None,
        having: Optional['types.RaceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RaceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RaceScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.RaceScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.RaceGroupByOutput']:
        """Group Race records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Race fields to group records by
        where
            Race filter to select records
        take
            Limit the maximum number of Race records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RaceGroupByOutput]
            A list of dictionaries representing the Race record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Race records by lineageId values
        # and count how many records are in each group
        results = await Race.prisma().group_by(
            ['lineageId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DescriptionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Description]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Description.prisma().query_raw(
            'SELECT * FROM Description WHERE id = $1',
            521827728,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Description
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Description.prisma().query_first(
            'SELECT * FROM Description WHERE indent = $1',
            1266032265,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DescriptionCreateInput,
        include: Optional[types.DescriptionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Description record.

        Parameters
        ----------
        data
            Description record data
        include
            Specifies which relations should be loaded on the returned Description model

        Returns
        -------
        prisma.models.Description
            The created Description record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Description record from just the required fields
        description = await Description.prisma().create(
            data={
                # data to create a Description record
                'indent': 93253262,
                'raceId': 2053047983,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DescriptionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Description records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Description record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Description.prisma().create_many(
            data=[
                {
                    # data to create a Description record
                    'indent': 685333180,
                    'raceId': 127474245,
                },
                {
                    # data to create a Description record
                    'indent': 948921754,
                    'raceId': 1964990155,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DescriptionWhereUniqueInput,
        include: Optional[types.DescriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Description record.

        Parameters
        ----------
        where
            Description filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Description model

        Returns
        -------
        prisma.models.Description
            The deleted Description record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        description = await Description.prisma().delete(
            where={
                'id': 1228891816,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DescriptionWhereUniqueInput,
        include: Optional[types.DescriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Description record.

        Parameters
        ----------
        where
            Description filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Description model

        Returns
        -------
        prisma.models.Description
            The found Description record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        description = await Description.prisma().find_unique(
            where={
                'id': 255202753,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DescriptionWhereUniqueInput,
        include: Optional[types.DescriptionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Description record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Description filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Description model

        Returns
        -------
        prisma.models.Description
            The found Description record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        description = await Description.prisma().find_unique_or_raise(
            where={
                'id': 1223573862,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DescriptionWhereInput] = None,
        cursor: Optional[types.DescriptionWhereUniqueInput] = None,
        include: Optional[types.DescriptionInclude] = None,
        order: Optional[Union[types.DescriptionOrderByInput, List[types.DescriptionOrderByInput]]] = None,
        distinct: Optional[List[types.DescriptionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Description records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Description records returned
        skip
            Ignore the first N results
        where
            Description filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Description model
        order
            Order the returned Description records by any field
        distinct
            Filter Description records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Description]
            The list of all Description records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Description records
        descriptions = await Description.prisma().find_many(take=10)

        # find the first 5 Description records ordered by the content field
        descriptions = await Description.prisma().find_many(
            take=5,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DescriptionWhereInput] = None,
        cursor: Optional[types.DescriptionWhereUniqueInput] = None,
        include: Optional[types.DescriptionInclude] = None,
        order: Optional[Union[types.DescriptionOrderByInput, List[types.DescriptionOrderByInput]]] = None,
        distinct: Optional[List[types.DescriptionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Description record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Description filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Description model
        order
            Order the returned Description records by any field
        distinct
            Filter Description records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Description
            The first Description record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Description record ordered by the raceId field
        description = await Description.prisma().find_first(
            skip=1,
            order={
                'raceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DescriptionWhereInput] = None,
        cursor: Optional[types.DescriptionWhereUniqueInput] = None,
        include: Optional[types.DescriptionInclude] = None,
        order: Optional[Union[types.DescriptionOrderByInput, List[types.DescriptionOrderByInput]]] = None,
        distinct: Optional[List[types.DescriptionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Description record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Description filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Description model
        order
            Order the returned Description records by any field
        distinct
            Filter Description records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Description
            The first Description record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Description record ordered by the id field
        description = await Description.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DescriptionUpdateInput,
        where: types.DescriptionWhereUniqueInput,
        include: Optional[types.DescriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Description record.

        Parameters
        ----------
        data
            Description record data specifying what to update
        where
            Description filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Description model

        Returns
        -------
        prisma.models.Description
            The updated Description record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        description = await Description.prisma().update(
            where={
                'id': 541269159,
            },
            data={
                # data to update the Description record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DescriptionWhereUniqueInput,
        data: types.DescriptionUpsertInput,
        include: Optional[types.DescriptionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Description filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Description model

        Returns
        -------
        prisma.models.Description
            The created or updated Description record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        description = await Description.prisma().upsert(
            where={
                'id': 1064846676,
            },
            data={
                'create': {
                    'id': 1064846676,
                    'indent': 948921754,
                    'raceId': 1964990155,
                },
                'update': {
                    'indent': 948921754,
                    'raceId': 1964990155,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DescriptionUpdateManyMutationInput,
        where: types.DescriptionWhereInput,
    ) -> int:
        """Update multiple Description records

        Parameters
        ----------
        data
            Description data to update the selected Description records to
        where
            Filter to select the Description records to update

        Returns
        -------
        int
            The total number of Description records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Description records
        total = await Description.prisma().update_many(
            data={
                'indent': 508382461
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DescriptionWhereInput] = None,
        cursor: Optional[types.DescriptionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Description records present in the database

        Parameters
        ----------
        select
            Select the Description fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Description filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DescriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Description.prisma().count()

        # results: prisma.types.DescriptionCountAggregateOutput
        results = await Description.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DescriptionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DescriptionWhereInput] = None,
        cursor: Optional[types.DescriptionWhereUniqueInput] = None,
    ) -> types.DescriptionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DescriptionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DescriptionWhereInput] = None,
        cursor: Optional[types.DescriptionWhereUniqueInput] = None,
    ) -> Union[int, types.DescriptionCountAggregateOutput]:
        """Count the number of Description records present in the database

        Parameters
        ----------
        select
            Select the Description fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Description filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DescriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Description.prisma().count()

        # results: prisma.types.DescriptionCountAggregateOutput
        results = await Description.prisma().count(
            select={
                '_all': True,
                'raceId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DescriptionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DescriptionWhereInput] = None
    ) -> int:
        """Delete multiple Description records.

        Parameters
        ----------
        where
            Optional Description filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Description records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Description records
        total = await Description.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DescriptionScalarFieldKeysT'],
        *,
        where: Optional['types.DescriptionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DescriptionAvgAggregateInput'] = None,
        sum: Optional['types.DescriptionSumAggregateInput'] = None,
        min: Optional['types.DescriptionMinAggregateInput'] = None,
        max: Optional['types.DescriptionMaxAggregateInput'] = None,
        having: Optional['types.DescriptionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DescriptionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DescriptionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.DescriptionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.DescriptionGroupByOutput']:
        """Group Description records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Description fields to group records by
        where
            Description filter to select records
        take
            Limit the maximum number of Description records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DescriptionGroupByOutput]
            A list of dictionaries representing the Description record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Description records by id values
        # and count how many records are in each group
        results = await Description.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FeatActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Feat]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Feat.prisma().query_raw(
            'SELECT * FROM Feat WHERE id = $1',
            1024265714,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Feat
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Feat.prisma().query_first(
            'SELECT * FROM Feat WHERE name = $1',
            'ihcahiead',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FeatCreateInput,
        include: Optional[types.FeatInclude] = None
    ) -> _PrismaModelT:
        """Create a new Feat record.

        Parameters
        ----------
        data
            Feat record data
        include
            Specifies which relations should be loaded on the returned Feat model

        Returns
        -------
        prisma.models.Feat
            The created Feat record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Feat record from just the required fields
        feat = await Feat.prisma().create(
            data={
                # data to create a Feat record
                'name': 'biheheiajg',
                'description': 'jbgijghgb',
                'indent': 769267518,
                'raceId': 820312479,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FeatCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Feat records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Feat record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Feat.prisma().create_many(
            data=[
                {
                    # data to create a Feat record
                    'name': 'jchciaee',
                    'description': 'deeificjd',
                    'indent': 1121741130,
                    'raceId': 1495896251,
                },
                {
                    # data to create a Feat record
                    'name': 'caifcbgii',
                    'description': 'igaibbfgj',
                    'indent': 1660932118,
                    'raceId': 525761943,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FeatWhereUniqueInput,
        include: Optional[types.FeatInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Feat record.

        Parameters
        ----------
        where
            Feat filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Feat model

        Returns
        -------
        prisma.models.Feat
            The deleted Feat record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        feat = await Feat.prisma().delete(
            where={
                'id': 736209796,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FeatWhereUniqueInput,
        include: Optional[types.FeatInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Feat record.

        Parameters
        ----------
        where
            Feat filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Feat model

        Returns
        -------
        prisma.models.Feat
            The found Feat record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        feat = await Feat.prisma().find_unique(
            where={
                'id': 493907821,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FeatWhereUniqueInput,
        include: Optional[types.FeatInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Feat record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Feat filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Feat model

        Returns
        -------
        prisma.models.Feat
            The found Feat record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        feat = await Feat.prisma().find_unique_or_raise(
            where={
                'id': 639686562,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FeatWhereInput] = None,
        cursor: Optional[types.FeatWhereUniqueInput] = None,
        include: Optional[types.FeatInclude] = None,
        order: Optional[Union[types.FeatOrderByInput, List[types.FeatOrderByInput]]] = None,
        distinct: Optional[List[types.FeatScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Feat records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Feat records returned
        skip
            Ignore the first N results
        where
            Feat filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Feat model
        order
            Order the returned Feat records by any field
        distinct
            Filter Feat records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Feat]
            The list of all Feat records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Feat records
        feats = await Feat.prisma().find_many(take=10)

        # find the first 5 Feat records ordered by the description field
        feats = await Feat.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FeatWhereInput] = None,
        cursor: Optional[types.FeatWhereUniqueInput] = None,
        include: Optional[types.FeatInclude] = None,
        order: Optional[Union[types.FeatOrderByInput, List[types.FeatOrderByInput]]] = None,
        distinct: Optional[List[types.FeatScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Feat record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Feat filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Feat model
        order
            Order the returned Feat records by any field
        distinct
            Filter Feat records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Feat
            The first Feat record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Feat record ordered by the indent field
        feat = await Feat.prisma().find_first(
            skip=1,
            order={
                'indent': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FeatWhereInput] = None,
        cursor: Optional[types.FeatWhereUniqueInput] = None,
        include: Optional[types.FeatInclude] = None,
        order: Optional[Union[types.FeatOrderByInput, List[types.FeatOrderByInput]]] = None,
        distinct: Optional[List[types.FeatScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Feat record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Feat filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Feat model
        order
            Order the returned Feat records by any field
        distinct
            Filter Feat records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Feat
            The first Feat record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Feat record ordered by the raceId field
        feat = await Feat.prisma().find_first_or_raise(
            skip=1,
            order={
                'raceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FeatUpdateInput,
        where: types.FeatWhereUniqueInput,
        include: Optional[types.FeatInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Feat record.

        Parameters
        ----------
        data
            Feat record data specifying what to update
        where
            Feat filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Feat model

        Returns
        -------
        prisma.models.Feat
            The updated Feat record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        feat = await Feat.prisma().update(
            where={
                'id': 654007347,
            },
            data={
                # data to update the Feat record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FeatWhereUniqueInput,
        data: types.FeatUpsertInput,
        include: Optional[types.FeatInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Feat filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Feat model

        Returns
        -------
        prisma.models.Feat
            The created or updated Feat record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        feat = await Feat.prisma().upsert(
            where={
                'id': 1905261552,
            },
            data={
                'create': {
                    'id': 1905261552,
                    'name': 'caifcbgii',
                    'description': 'igaibbfgj',
                    'indent': 1660932118,
                    'raceId': 525761943,
                },
                'update': {
                    'name': 'caifcbgii',
                    'description': 'igaibbfgj',
                    'indent': 1660932118,
                    'raceId': 525761943,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FeatUpdateManyMutationInput,
        where: types.FeatWhereInput,
    ) -> int:
        """Update multiple Feat records

        Parameters
        ----------
        data
            Feat data to update the selected Feat records to
        where
            Filter to select the Feat records to update

        Returns
        -------
        int
            The total number of Feat records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Feat records
        total = await Feat.prisma().update_many(
            data={
                'id': 78746985
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FeatWhereInput] = None,
        cursor: Optional[types.FeatWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Feat records present in the database

        Parameters
        ----------
        select
            Select the Feat fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Feat filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FeatCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Feat.prisma().count()

        # results: prisma.types.FeatCountAggregateOutput
        results = await Feat.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FeatCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FeatWhereInput] = None,
        cursor: Optional[types.FeatWhereUniqueInput] = None,
    ) -> types.FeatCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FeatCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FeatWhereInput] = None,
        cursor: Optional[types.FeatWhereUniqueInput] = None,
    ) -> Union[int, types.FeatCountAggregateOutput]:
        """Count the number of Feat records present in the database

        Parameters
        ----------
        select
            Select the Feat fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Feat filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FeatCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Feat.prisma().count()

        # results: prisma.types.FeatCountAggregateOutput
        results = await Feat.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FeatCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FeatWhereInput] = None
    ) -> int:
        """Delete multiple Feat records.

        Parameters
        ----------
        where
            Optional Feat filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Feat records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Feat records
        total = await Feat.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FeatScalarFieldKeysT'],
        *,
        where: Optional['types.FeatWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FeatAvgAggregateInput'] = None,
        sum: Optional['types.FeatSumAggregateInput'] = None,
        min: Optional['types.FeatMinAggregateInput'] = None,
        max: Optional['types.FeatMaxAggregateInput'] = None,
        having: Optional['types.FeatScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FeatCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FeatScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.FeatScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.FeatGroupByOutput']:
        """Group Feat records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Feat fields to group records by
        where
            Feat filter to select records
        take
            Limit the maximum number of Feat records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FeatGroupByOutput]
            A list of dictionaries representing the Feat record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Feat records by indent values
        # and count how many records are in each group
        results = await Feat.prisma().group_by(
            ['indent'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Table]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Table.prisma().query_raw(
            'SELECT * FROM Table WHERE id = $1',
            1398328302,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Table
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Table.prisma().query_first(
            'SELECT * FROM Table WHERE name = $1',
            'ifgaaagff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TableCreateInput,
        include: Optional[types.TableInclude] = None
    ) -> _PrismaModelT:
        """Create a new Table record.

        Parameters
        ----------
        data
            Table record data
        include
            Specifies which relations should be loaded on the returned Table model

        Returns
        -------
        prisma.models.Table
            The created Table record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Table record from just the required fields
        table = await Table.prisma().create(
            data={
                # data to create a Table record
                'descriptionId': 1452336924,
                'featId': 1573199653,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Table records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Table record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Table.prisma().create_many(
            data=[
                {
                    # data to create a Table record
                    'descriptionId': 2013903098,
                    'featId': 500965035,
                },
                {
                    # data to create a Table record
                    'descriptionId': 1800624392,
                    'featId': 2077067425,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TableWhereUniqueInput,
        include: Optional[types.TableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Table record.

        Parameters
        ----------
        where
            Table filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Table model

        Returns
        -------
        prisma.models.Table
            The deleted Table record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        table = await Table.prisma().delete(
            where={
                'id': 1672112838,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TableWhereUniqueInput,
        include: Optional[types.TableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Table record.

        Parameters
        ----------
        where
            Table filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Table model

        Returns
        -------
        prisma.models.Table
            The found Table record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        table = await Table.prisma().find_unique(
            where={
                'id': 926677639,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TableWhereUniqueInput,
        include: Optional[types.TableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Table record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Table filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Table model

        Returns
        -------
        prisma.models.Table
            The found Table record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        table = await Table.prisma().find_unique_or_raise(
            where={
                'id': 1447624116,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TableWhereInput] = None,
        cursor: Optional[types.TableWhereUniqueInput] = None,
        include: Optional[types.TableInclude] = None,
        order: Optional[Union[types.TableOrderByInput, List[types.TableOrderByInput]]] = None,
        distinct: Optional[List[types.TableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Table records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Table records returned
        skip
            Ignore the first N results
        where
            Table filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Table model
        order
            Order the returned Table records by any field
        distinct
            Filter Table records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Table]
            The list of all Table records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Table records
        tables = await Table.prisma().find_many(take=10)

        # find the first 5 Table records ordered by the header field
        tables = await Table.prisma().find_many(
            take=5,
            order={
                'header': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TableWhereInput] = None,
        cursor: Optional[types.TableWhereUniqueInput] = None,
        include: Optional[types.TableInclude] = None,
        order: Optional[Union[types.TableOrderByInput, List[types.TableOrderByInput]]] = None,
        distinct: Optional[List[types.TableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Table record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Table filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Table model
        order
            Order the returned Table records by any field
        distinct
            Filter Table records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Table
            The first Table record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Table record ordered by the descriptionId field
        table = await Table.prisma().find_first(
            skip=1,
            order={
                'descriptionId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TableWhereInput] = None,
        cursor: Optional[types.TableWhereUniqueInput] = None,
        include: Optional[types.TableInclude] = None,
        order: Optional[Union[types.TableOrderByInput, List[types.TableOrderByInput]]] = None,
        distinct: Optional[List[types.TableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Table record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Table filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Table model
        order
            Order the returned Table records by any field
        distinct
            Filter Table records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Table
            The first Table record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Table record ordered by the featId field
        table = await Table.prisma().find_first_or_raise(
            skip=1,
            order={
                'featId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TableUpdateInput,
        where: types.TableWhereUniqueInput,
        include: Optional[types.TableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Table record.

        Parameters
        ----------
        data
            Table record data specifying what to update
        where
            Table filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Table model

        Returns
        -------
        prisma.models.Table
            The updated Table record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        table = await Table.prisma().update(
            where={
                'id': 1738083805,
            },
            data={
                # data to update the Table record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TableWhereUniqueInput,
        data: types.TableUpsertInput,
        include: Optional[types.TableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Table filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Table model

        Returns
        -------
        prisma.models.Table
            The created or updated Table record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        table = await Table.prisma().upsert(
            where={
                'id': 340946258,
            },
            data={
                'create': {
                    'id': 340946258,
                    'descriptionId': 1800624392,
                    'featId': 2077067425,
                },
                'update': {
                    'descriptionId': 1800624392,
                    'featId': 2077067425,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TableUpdateManyMutationInput,
        where: types.TableWhereInput,
    ) -> int:
        """Update multiple Table records

        Parameters
        ----------
        data
            Table data to update the selected Table records to
        where
            Filter to select the Table records to update

        Returns
        -------
        int
            The total number of Table records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Table records
        total = await Table.prisma().update_many(
            data={
                'id': 601077795
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TableWhereInput] = None,
        cursor: Optional[types.TableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Table records present in the database

        Parameters
        ----------
        select
            Select the Table fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Table filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Table.prisma().count()

        # results: prisma.types.TableCountAggregateOutput
        results = await Table.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TableWhereInput] = None,
        cursor: Optional[types.TableWhereUniqueInput] = None,
    ) -> types.TableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TableWhereInput] = None,
        cursor: Optional[types.TableWhereUniqueInput] = None,
    ) -> Union[int, types.TableCountAggregateOutput]:
        """Count the number of Table records present in the database

        Parameters
        ----------
        select
            Select the Table fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Table filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Table.prisma().count()

        # results: prisma.types.TableCountAggregateOutput
        results = await Table.prisma().count(
            select={
                '_all': True,
                'header': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TableWhereInput] = None
    ) -> int:
        """Delete multiple Table records.

        Parameters
        ----------
        where
            Optional Table filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Table records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Table records
        total = await Table.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TableScalarFieldKeysT'],
        *,
        where: Optional['types.TableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TableAvgAggregateInput'] = None,
        sum: Optional['types.TableSumAggregateInput'] = None,
        min: Optional['types.TableMinAggregateInput'] = None,
        max: Optional['types.TableMaxAggregateInput'] = None,
        having: Optional['types.TableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TableScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TableScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TableGroupByOutput']:
        """Group Table records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Table fields to group records by
        where
            Table filter to select records
        take
            Limit the maximum number of Table records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TableGroupByOutput]
            A list of dictionaries representing the Table record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Table records by descriptionId values
        # and count how many records are in each group
        results = await Table.prisma().group_by(
            ['descriptionId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RowActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Row]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Row.prisma().query_raw(
            'SELECT * FROM Row WHERE id = $1',
            290603296,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Row
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Row.prisma().query_first(
            'SELECT * FROM Row WHERE content = $1',
            ['bifficggej'],
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RowCreateInput,
        include: Optional[types.RowInclude] = None
    ) -> _PrismaModelT:
        """Create a new Row record.

        Parameters
        ----------
        data
            Row record data
        include
            Specifies which relations should be loaded on the returned Row model

        Returns
        -------
        prisma.models.Row
            The created Row record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Row record from just the required fields
        row = await Row.prisma().create(
            data={
                # data to create a Row record
                'tableId': 1611009182,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RowCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Row records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Row record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Row.prisma().create_many(
            data=[
                {
                    # data to create a Row record
                    'tableId': 446673791,
                },
                {
                    # data to create a Row record
                    'tableId': 300568396,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RowWhereUniqueInput,
        include: Optional[types.RowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Row record.

        Parameters
        ----------
        where
            Row filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Row model

        Returns
        -------
        prisma.models.Row
            The deleted Row record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        row = await Row.prisma().delete(
            where={
                'id': 632626069,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RowWhereUniqueInput,
        include: Optional[types.RowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Row record.

        Parameters
        ----------
        where
            Row filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Row model

        Returns
        -------
        prisma.models.Row
            The found Row record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        row = await Row.prisma().find_unique(
            where={
                'id': 1724011690,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RowWhereUniqueInput,
        include: Optional[types.RowInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Row record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Row filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Row model

        Returns
        -------
        prisma.models.Row
            The found Row record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        row = await Row.prisma().find_unique_or_raise(
            where={
                'id': 470157467,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RowWhereInput] = None,
        cursor: Optional[types.RowWhereUniqueInput] = None,
        include: Optional[types.RowInclude] = None,
        order: Optional[Union[types.RowOrderByInput, List[types.RowOrderByInput]]] = None,
        distinct: Optional[List[types.RowScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Row records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Row records returned
        skip
            Ignore the first N results
        where
            Row filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Row model
        order
            Order the returned Row records by any field
        distinct
            Filter Row records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Row]
            The list of all Row records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Row records
        rows = await Row.prisma().find_many(take=10)

        # find the first 5 Row records ordered by the tableId field
        rows = await Row.prisma().find_many(
            take=5,
            order={
                'tableId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RowWhereInput] = None,
        cursor: Optional[types.RowWhereUniqueInput] = None,
        include: Optional[types.RowInclude] = None,
        order: Optional[Union[types.RowOrderByInput, List[types.RowOrderByInput]]] = None,
        distinct: Optional[List[types.RowScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Row record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Row filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Row model
        order
            Order the returned Row records by any field
        distinct
            Filter Row records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Row
            The first Row record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Row record ordered by the id field
        row = await Row.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RowWhereInput] = None,
        cursor: Optional[types.RowWhereUniqueInput] = None,
        include: Optional[types.RowInclude] = None,
        order: Optional[Union[types.RowOrderByInput, List[types.RowOrderByInput]]] = None,
        distinct: Optional[List[types.RowScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Row record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Row filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Row model
        order
            Order the returned Row records by any field
        distinct
            Filter Row records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Row
            The first Row record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Row record ordered by the content field
        row = await Row.prisma().find_first_or_raise(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RowUpdateInput,
        where: types.RowWhereUniqueInput,
        include: Optional[types.RowInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Row record.

        Parameters
        ----------
        data
            Row record data specifying what to update
        where
            Row filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Row model

        Returns
        -------
        prisma.models.Row
            The updated Row record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        row = await Row.prisma().update(
            where={
                'id': 1209209912,
            },
            data={
                # data to update the Row record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RowWhereUniqueInput,
        data: types.RowUpsertInput,
        include: Optional[types.RowInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Row filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Row model

        Returns
        -------
        prisma.models.Row
            The created or updated Row record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        row = await Row.prisma().upsert(
            where={
                'id': 1536744465,
            },
            data={
                'create': {
                    'id': 1536744465,
                    'tableId': 300568396,
                },
                'update': {
                    'tableId': 300568396,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RowUpdateManyMutationInput,
        where: types.RowWhereInput,
    ) -> int:
        """Update multiple Row records

        Parameters
        ----------
        data
            Row data to update the selected Row records to
        where
            Filter to select the Row records to update

        Returns
        -------
        int
            The total number of Row records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Row records
        total = await Row.prisma().update_many(
            data={
                'tableId': 424218998
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RowWhereInput] = None,
        cursor: Optional[types.RowWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Row records present in the database

        Parameters
        ----------
        select
            Select the Row fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Row filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Row.prisma().count()

        # results: prisma.types.RowCountAggregateOutput
        results = await Row.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RowCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RowWhereInput] = None,
        cursor: Optional[types.RowWhereUniqueInput] = None,
    ) -> types.RowCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RowCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RowWhereInput] = None,
        cursor: Optional[types.RowWhereUniqueInput] = None,
    ) -> Union[int, types.RowCountAggregateOutput]:
        """Count the number of Row records present in the database

        Parameters
        ----------
        select
            Select the Row fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Row filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RowCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Row.prisma().count()

        # results: prisma.types.RowCountAggregateOutput
        results = await Row.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RowCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RowWhereInput] = None
    ) -> int:
        """Delete multiple Row records.

        Parameters
        ----------
        where
            Optional Row filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Row records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Row records
        total = await Row.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RowScalarFieldKeysT'],
        *,
        where: Optional['types.RowWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RowAvgAggregateInput'] = None,
        sum: Optional['types.RowSumAggregateInput'] = None,
        min: Optional['types.RowMinAggregateInput'] = None,
        max: Optional['types.RowMaxAggregateInput'] = None,
        having: Optional['types.RowScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RowCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RowScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.RowScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.RowGroupByOutput']:
        """Group Row records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Row fields to group records by
        where
            Row filter to select records
        take
            Limit the maximum number of Row records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RowGroupByOutput]
            A list of dictionaries representing the Row record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Row records by tableId values
        # and count how many records are in each group
        results = await Row.prisma().group_by(
            ['tableId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models